// Generated by CoffeeScript 1.4.0
(function() {
  var FekitConfig, Reader, UrlConvert, Writer, async, casexists, child_process, cjson, coffee, crypto, exit, find, fs, fse, fstream, ignore, mkdirp, ncp, request, rimraf, sty, syspath, sysutil, tar, utilarray, utilasync, utilconfig, utilfile, utilhttp, utillogger, utilpath, utilproc, utilself, utilsys, vm, yaml, zlib, _, _closest, _closest_dir, _fileExistsWithCaseSync, _filters, _runCode, _watch;

  _ = require('underscore');

  async = require('async');

  child_process = require('child_process');

  cjson = require('cjson');

  coffee = require('coffee-script');

  crypto = require('crypto');

  find = require('find');

  fs = require('fs');

  fse = require('fs-extra');

  fstream = require('fstream');

  ignore = require('ignore');

  mkdirp = require('mkdirp');

  ncp = require('ncp').ncp;

  request = require('request');

  rimraf = require('rimraf');

  sty = require('sty');

  syspath = require('path');

  sysutil = require('util');

  tar = require('tar');

  vm = require('vm');

  yaml = require('js-yaml');

  zlib = require('zlib');

  utilself = module.exports;

  exports.array = utilarray = {
    clear_empty: function(array) {
      var i, n, _i, _len;
      n = [];
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        i = array[_i];
        if (i !== "" || i !== null) {
          n.push(i);
        }
      }
      return n;
    }
  };

  _closest = function(p, findfilename, filterFunc) {
    var dir, file, files, _i, _len;
    if (p === "/" || (process.platform === "win32" && p.match(/^[a-zA-Z]:(\\|\/)?$/))) {
      return null;
    }
    if (utilpath.is_directory(p)) {
      dir = p;
    } else {
      dir = syspath.dirname(p);
    }
    files = fs.readdirSync(dir);
    for (_i = 0, _len = files.length; _i < _len; _i++) {
      file = files[_i];
      if (file === findfilename) {
        if (filterFunc) {
          if (filterFunc(utilpath.join(dir, file))) {
            return dir;
          }
        } else {
          return dir;
        }
      }
    }
    return _closest(syspath.dirname(dir), findfilename, filterFunc);
  };

  _closest_dir = function(p, finddirname, filterFunc) {
    var dir, file, files, _i, _len;
    if (p === "/" || (process.platform === "win32" && p.match(/^[a-zA-Z]:(\\|\/)?$/))) {
      return null;
    }
    if (utilpath.is_directory(p)) {
      dir = p;
    } else {
      dir = syspath.dirname(p);
    }
    files = fs.readdirSync(dir);
    for (_i = 0, _len = files.length; _i < _len; _i++) {
      file = files[_i];
      if (file === finddirname && utilpath.is_directory(file)) {
        if (filterFunc) {
          if (filterFunc(file)) {
            return dir;
          }
        } else {
          return dir;
        }
      }
    }
    return _closest_dir(syspath.dirname(dir), finddirname, filterFunc);
  };

  _fileExistsWithCaseSync = function(filepath) {
    var dir, filenames;
    if (!fs.existsSync(filepath)) {
      return false;
    }
    dir = syspath.dirname(filepath);
    if (dir === '/' || dir === '.' || (/^\w:\\$/.test(dir))) {
      return true;
    }
    filenames = fs.readdirSync(dir);
    if (filenames.indexOf(syspath.basename(filepath)) === -1) {
      return false;
    }
    return _fileExistsWithCaseSync(dir);
  };

  casexists = require('exists-case');

  exports.path = utilpath = {
    extname: syspath.extname,
    dirname: syspath.dirname,
    basename: syspath.basename,
    resolve: syspath.resolve,
    join: function() {
      var arr, i;
      arr = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = arguments.length; _i < _len; _i++) {
          i = arguments[_i];
          _results.push(typeof i === 'undefined' ? '' : i);
        }
        return _results;
      }).apply(this, arguments);
      return syspath.join.apply(syspath, arr);
    },
    fname: function(path) {
      return syspath.basename(path).replace(syspath.extname(path), '');
    },
    get_user_home: function() {
      return process.env[process.platform === 'win32' ? 'USERPROFILE' : 'HOME'];
    },
    closest: function(path, findfilename, is_directory, filterFunc) {
      if (is_directory) {
        return _closest_dir(path, findfilename, filterFunc);
      } else {
        return _closest(path, findfilename, filterFunc);
      }
    },
    SEPARATOR: syspath.sep,
    is_root: function(path) {
      var p;
      if (process.platform === 'win32') {
        p = path.replace(syspath.sep, '');
        return /^[a-z]:\s*$/i.test(p);
      } else {
        return syspath.sep === path;
      }
    },
    exists: function(path, sensitive) {
      if (sensitive) {
        return casexists.sync(path);
      } else {
        return fs.existsSync(path);
      }
    },
    split_path: function(path, ext_list) {
      var ext, parts;
      if (~path.indexOf("/")) {
        parts = path.split("/");
      } else if (~path.indexOf("\\")) {
        parts = path.split("\\");
      } else {
        parts = path.split(".");
      }
      parts = utilarray.clear_empty(parts);
      ext = "." + parts[parts.length - 1];
      if (~ext_list.indexOf(ext)) {
        parts = parts.slice(0, parts.length - 1);
        parts[parts.length - 1] = parts[parts.length - 1] + ext;
      }
      return parts;
    },
    is_directory: function(path) {
      var stats;
      try {
        stats = fs.statSync(path);
        return stats.isDirectory();
      } catch (err) {
        throw err;
        return false;
      }
    },
    is_normalize_dirname: function(path) {
      return (/[\w-\.\s]+/i.test(path)) && (path !== '.') && (path !== '..') && (path !== '.svn') && (path !== '.git');
    },
    each_directory: function(path, cb, is_recursion) {
      var f, list, p, _i, _len, _results;
      if (!utilpath.is_directory(path)) {
        path = syspath.dirname(path);
      }
      list = fs.readdirSync(path);
      _results = [];
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        f = list[_i];
        p = syspath.join(path, f);
        if (!is_recursion) {
          if (utilpath.is_normalize_dirname(f) && !utilpath.is_directory(p)) {
            _results.push(cb(p));
          } else {
            _results.push(void 0);
          }
        } else {
          if (utilpath.is_normalize_dirname(f)) {
            if (!utilpath.is_directory(p)) {
              _results.push(cb(p));
            } else {
              _results.push(utilpath.each_directory(p, cb, is_recursion));
            }
          } else {
            _results.push(void 0);
          }
        }
      }
      return _results;
    },
    existsFiles: function(root, filenames) {
      var name, p, _i, _len;
      for (_i = 0, _len = filenames.length; _i < _len; _i++) {
        name = filenames[_i];
        p = syspath.join(root, name);
        if (utilpath.exists(p)) {
          return p;
        }
      }
      throw "找不到文件列表中的任一文件 " + root + " 下的 [" + (filenames.join()) + "]";
    },
    is_absolute_path: function(path) {
      return (process.platform === "win32" && (/^[a-zA-Z]:(\\|\/)?/.test(path))) || path.charAt(0) === "/";
    }
  };

  Reader = (function() {

    function Reader() {}

    Reader.prototype.readlines = function(filepath) {
      return this.read(filepath).toString().split(utilfile.NEWLINE);
    };

    Reader.prototype.read = function(filepath) {
      if (!utilpath.exists(filepath)) {
        throw "找不到文件 " + filepath;
      }
      return fs.readFileSync(filepath).toString().replace(/\r\n/g, '\n');
    };

    Reader.prototype.readJSON = function(filepath) {
      try {
        return cjson.load(filepath);
      } catch (err) {
        throw "解析 " + filepath + " 时出现错误, 请检查该文件, 该文件必须是标准JSON格式";
      }
    };

    Reader.prototype.readYAML = function(filepath) {
      try {
        return yaml.load(fs.readFileSync(filepath).toString());
      } catch (err) {
        throw "解析 " + filepath + " 时出现错误, 请检查该文件, 该文件必须是标准YAML格式";
      }
    };

    Reader.prototype.readbymtime = function(filepath) {
      var cache, mtime;
      mtime = null;
      cache = null;
      return function() {
        var stat;
        stat = fs.statSync(filepath);
        if (stat.mtime !== mtime) {
          mtime = stat.mtime;
          cache = utilfile.io.read(filepath);
        }
        return cache;
      };
    };

    return Reader;

  })();

  Writer = (function() {

    function Writer() {}

    Writer.prototype.write = function(filepath, content) {
      if (!utilpath.exists(syspath.dirname(filepath))) {
        mkdirp.sync(syspath.dirname(filepath));
      }
      return fs.writeFileSync(filepath, content);
    };

    return Writer;

  })();

  exports.file = utilfile = {};

  utilfile.reader = Reader;

  utilfile.writer = Writer;

  utilfile.io = _.extend({}, Reader.prototype, Writer.prototype);

  utilfile.NEWLINE = '\n';

  _watch = function(path, cb) {
    var f, list, p, watcher, _i, _len, _results;
    if (!utilpath.is_directory(path)) {
      path = syspath.dirname(path);
    }
    watcher = fs.watch(path, cb);
    watcher.on('error', function(e) {
      watcher.close();
      return watcher = null;
    });
    list = fs.readdirSync(path);
    _results = [];
    for (_i = 0, _len = list.length; _i < _len; _i++) {
      f = list[_i];
      p = syspath.join(path, f);
      if (utilpath.is_normalize_dirname(f) && utilpath.is_directory(p)) {
        _results.push(_watch(p, cb));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  utilfile.watch = function(dest, cb, crashCB) {
    return _watch(dest, cb, crashCB);
  };

  utilfile.copy = function(srcFile, destFile) {
    var BUF_LENGTH, buff, bytesRead, fdr, fdw, pos;
    BUF_LENGTH = 64 * 1024;
    buff = new Buffer(BUF_LENGTH);
    fdr = fs.openSync(srcFile, 'r');
    fdw = fs.openSync(destFile, 'w');
    bytesRead = 1;
    pos = 0;
    while (bytesRead > 0) {
      bytesRead = fs.readSync(fdr, buff, 0, BUF_LENGTH, pos);
      fs.writeSync(fdw, buff, 0, bytesRead);
      pos += bytesRead;
    }
    fs.closeSync(fdr);
    return fs.closeSync(fdw);
  };

  utilfile.cpr = function(src, dest, cb) {
    return ncp(src, dest, cb);
  };

  utilfile.cprSync = fse.copySync;

  utilfile.rmrf = function(dest, cb) {
    if (cb) {
      return rimraf(dest, cb);
    } else {
      return rimraf.sync(dest);
    }
  };

  utilfile.rmrfSync = fse.removeSync;

  utilfile.mkdirp = mkdirp.sync;

  utilfile.findify = function(path_without_extname, ext_list) {
    var ext, list, path, _i, _len;
    if (utilpath.exists(path_without_extname) && !utilpath.is_directory(path_without_extname)) {
      return path_without_extname;
    }
    list = [""].concat(ext_list);
    for (_i = 0, _len = list.length; _i < _len; _i++) {
      ext = list[_i];
      path = path_without_extname + ext;
      if (utilpath.exists(path) && !utilpath.is_directory(path)) {
        return path;
      }
    }
    return null;
  };

  /*
      {
          // 别名配置
          "alias" : {
              "core" : "./src/scripts/core"
          } ,
          // 导出配置 , 默认是以src为根目录
          // 输出至 dev 就变为 scripts/page-a@dev.js
          // 输出至 prd 就变为 scripts/page-a@(md5).js
          "export" : [
              "scripts/page-a.js"
          ] ,
          // sync 使用的配置
          "dev" : {
              "host" : "127.0.0.1"
              "path" : "/home/q/"
          }
      }
  */


  FekitConfig = (function() {

    function FekitConfig(baseUri) {
      this.baseUri = baseUri;
      this.fekit_config_filename = "fekit.config";
      this.fekit_root_dirname = utilpath.closest(this.baseUri, this.fekit_config_filename);
      this.fekit_config_path = syspath.join(this.fekit_root_dirname || "", this.fekit_config_filename);
      try {
        this.root = new utilfile.reader().readJSON(this.fekit_config_path);
        if (!this.getAlias()) {
          this.root.alias = {};
        }
      } catch (err) {
        if (utilpath.exists(this.fekit_config_path)) {
          throw "" + this.fekit_config_filename + " 解析失败, 请确认该文件格式是否符合正确的JSON格式";
        } else {
          this.root = {
            "alias": {},
            "export": []
          };
        }
      }
    }

    FekitConfig.prototype.getAlias = function(name) {
      var _ref, _ref1;
      if (!name) {
        return this.root.alias || this.root.lib;
      } else {
        return ((_ref = this.root.alias) != null ? _ref[name] : void 0) || ((_ref1 = this.root.lib) != null ? _ref1[name] : void 0);
      }
    };

    FekitConfig.prototype.getExportFileConfig = function(fullpath) {
      var n;
      n = null;
      this.each_export_files(function(path, parents, opts) {
        if (path === fullpath) {
          return n = opts;
        }
      });
      return n;
    };

    FekitConfig.prototype.get_export_list = function() {
      return this.root["export"] || [];
    };

    FekitConfig.prototype.get_export_info = function(file) {
      var opts, parents, path,
        _this = this;
      opts = {};
      if (_.isObject(file)) {
        path = syspath.join(this.fekit_root_dirname, "src", file.path);
        parents = _.map(file.parents || [], function(ppath) {
          return syspath.join(_this.fekit_root_dirname, "src", ppath);
        });
        opts = file;
        opts.partial_path = file.path;
      } else {
        path = syspath.join(this.fekit_root_dirname, "src", file);
        parents = [];
        opts.path = path;
        opts.partial_path = file;
      }
      return {
        path: path,
        parents: parents,
        opts: opts
      };
    };

    FekitConfig.prototype.each_export_files = function(cb) {
      var file, list, o, self, _i, _len, _results;
      self = this;
      list = this.root["export"] || [];
      _results = [];
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        file = list[_i];
        o = self.get_export_info(file);
        if (utilpath.exists(o.path)) {
          _results.push(cb(o.path, o.parents, o.opts));
        } else {
          _results.push(utillogger.error("找不到文件 " + o.path));
        }
      }
      return _results;
    };

    FekitConfig.prototype.each_export_files_async = function(cb, doneCallback) {
      var file, list, self, tasks, _i, _len, _tmp,
        _this = this;
      self = this;
      tasks = [];
      list = this.root["export"] || [];
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        file = list[_i];
        _tmp = function(file) {
          return function(seriesCallback) {
            var o;
            o = self.get_export_info(file);
            if (utilpath.exists(o.path)) {
              return cb(o.path, o.parents, o.opts, seriesCallback);
            } else {
              utillogger.error("找不到文件 " + o.path);
              return utilproc.setImmediate(seriesCallback);
            }
          };
        };
        tasks.push(_tmp(file));
      }
      return async.series(tasks, function(err) {
        if (err) {
          throw err;
        }
        return doneCallback();
      });
    };

    FekitConfig.prototype.findExportFile = function(filepath, cb) {
      var file, hit, list, parents, path, _i, _len,
        _this = this;
      list = this.root["export"] || [];
      hit = false;
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        file = list[_i];
        if (_.isObject(file)) {
          path = syspath.join(this.fekit_root_dirname, "src", file.path);
          parents = _.map(file.parents || [], function(ppath) {
            return syspath.join(_this.fekit_root_dirname, "src", ppath);
          });
        } else {
          path = syspath.join(this.fekit_root_dirname, "src", file);
          parents = [];
        }
        if (filepath === path) {
          hit = true;
          cb(filepath, parents);
        }
      }
      if (!hit) {
        return cb(null, []);
      }
    };

    FekitConfig.prototype.doScript = function(type, context) {
      var ctx, path, _ref, _ref1;
      ctx = context || {};
      ctx.path = utilpath;
      ctx.file = utilfile;
      ctx.cwd = this.baseUri;
      ctx.refs_path = this.refs_path;
      ctx.io = {
        reader: new Reader(),
        writer: new Writer()
      };
      path = (_ref = this.root) != null ? (_ref1 = _ref.scripts) != null ? _ref1[type] : void 0 : void 0;
      if (!path) {
        return;
      }
      path = syspath.join(this.fekit_root_dirname, path);
      if (!utilpath.exists(path)) {
        return;
      }
      utillogger.log("检测到自动脚本 " + type + " , 开始执行.");
      _runCode(path, ctx);
      return utillogger.log("自动脚本 " + type + " , 执行完毕.");
    };

    FekitConfig.prototype.doRefs = function(options) {
      var fn, k, list, v;
      this.refs_path = utilpath.join(this.baseUri, "refs");
      utilfile.rmrfSync(this.refs_path);
      utilfile.mkdirp(this.refs_path);
      utillogger.log("[refs] start");
      list = this.root.refs || {};
      for (k in list) {
        v = list[k];
        fn = this["_doRefs_" + k];
        if (fn) {
          fn.apply(this, (!sysutil.isArray(v) ? [v] : v));
        } else {
          utillogger.error("[refs] 构建任务失败, 找不到命令 " + k);
        }
      }
      return this._doRefs_env(options);
    };

    FekitConfig.prototype._doRefs_cp = function() {
      var dir, from, to, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = arguments.length; _i < _len; _i++) {
        dir = arguments[_i];
        from = utilpath.join(this.baseUri, dir);
        to = utilpath.join(this.refs_path, dir);
        utillogger.log("\t >>> " + from + " -> " + to);
        if (utilpath.exists(from)) {
          _results.push(utilfile.cprSync(from, to));
        } else {
          _results.push(utillogger.error("\t" + from + " 不存在"));
        }
      }
      return _results;
    };

    FekitConfig.prototype._doRefs_sh = function(script) {
      var ctx, script_path;
      script_path = utilpath.join(this.baseUri, script);
      if (!utilpath.exists(script_path)) {
        return;
      }
      utillogger.log("\t >>> run script [" + script + "]");
      ctx = {};
      ctx.path = utilpath;
      ctx.file = utilfile;
      ctx.cwd = this.baseUri;
      ctx.refs_path = this.refs_path;
      return _runCode(script_path, ctx);
    };

    FekitConfig.prototype._doRefs_env = function(options) {
      var file, files, fn, k, reg, _results;
      _results = [];
      for (k in _filters) {
        fn = _filters[k];
        reg = new RegExp(k, "i");
        files = find.fileSync(reg, this.refs_path);
        _results.push((function() {
          var _i, _len, _results1;
          _results1 = [];
          for (_i = 0, _len = files.length; _i < _len; _i++) {
            file = files[_i];
            _results1.push(this._do_filter(fn.bind(this), file, options, this));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    FekitConfig.prototype.getEnvironmentConfig = function() {
      var default_json, has, j, p, _ref;
      j = utilpath.join;
      has = utilpath.exists;
      p = j(this.fekit_root_dirname, "environment.yaml");
      if (has(p)) {
        return utilfile.io.readYAML(p);
      }
      p = j(this.fekit_root_dirname, "environment.json");
      if (has(p)) {
        return utilfile.io.readJSON(p);
      }
      default_json = {
        dev: {},
        beta: {},
        prd: {}
      };
      return ((_ref = this.root) != null ? _ref.environment : void 0) || default_json;
    };

    FekitConfig.prototype._do_filter = function(fn, filepath, options, conf) {
      var source;
      source = utilfile.io.read(filepath);
      source = fn(source, options, conf);
      return utilfile.io.write(filepath, source);
    };

    return FekitConfig;

  })();

  _filters = {
    ".*\\.html$": function(source, options, conf) {
      var env;
      env = utilself.getCurrentEnvironment(options);
      return utilself.replaceEnvironmentConfig('text', source, this.getEnvironmentConfig()[env]);
    },
    ".*\\.htm$": function(source, options) {
      var env;
      env = utilself.getCurrentEnvironment(options);
      return utilself.replaceEnvironmentConfig('text', source, this.getEnvironmentConfig()[env]);
    },
    ".*\\.vm$": function(source, options) {
      var env;
      env = utilself.getCurrentEnvironment(options);
      return utilself.replaceEnvironmentConfig('text', source, this.getEnvironmentConfig()[env]);
    }
  };

  _runCode = function(path, ctx) {
    var Module, code, context, m, mod;
    Module = require('module');
    mod = new Module(path);
    context = _.extend({}, global, ctx);
    context.module = mod;
    context.__filename = path;
    context.__dirname = syspath.dirname(path);
    context.require = function(path) {
      return mod.require(path);
    };
    code = new Reader().read(path);
    switch (syspath.extname(path)) {
      case ".js":
        code = code;
        break;
      case ".coffee":
        code = coffee.compile(code);
        break;
      default:
        throw "没有正确的自动化脚本解析器 " + path;
    }
    m = vm.createScript(code);
    return m.runInNewContext(context);
  };

  exports.config = utilconfig = {
    parse: function(baseUri) {
      return new FekitConfig(baseUri);
    },
    createEmptySchema: function() {
      return {
        "compiler": "modular",
        "name": "",
        "version": "",
        "dependencies": {},
        "alias": {},
        "export": []
      };
    }
  };

  UrlConvert = (function() {

    function UrlConvert(uri, root) {
      var baseuri, extname, filename, fnames, _tmp,
        _this = this;
      this.uri = uri;
      this.root = root;
      this.REPLACE_STRING = "##REPLACE##";
      if (!this.root) {
        baseuri = this.uri.replace(/[\/\\](dev|prd|src)[\/\\]/, function($0, $1) {
          return "/" + _this.REPLACE_STRING + "/";
        });
      } else {
        _tmp = (this.uri.replace(this.root, "")).replace(/[\/\\](dev|prd|src)[\/\\]/, function($0, $1) {
          return "/" + _this.REPLACE_STRING + "/";
        });
        baseuri = syspath.join(this.root, _tmp);
      }
      extname = syspath.extname(baseuri);
      filename = syspath.basename(baseuri, extname);
      baseuri = baseuri.replace(filename + extname, "");
      fnames = filename.split("@");
      this.baseuri = baseuri;
      this.extname = extname;
      this.replaced_extname = extname;
      this.filename = filename;
      this.fnames = fnames;
      this.has_version = true;
    }

    UrlConvert.prototype.set_extname_type = function(type) {
      type = type || "";
      switch (type.toLowerCase()) {
        case "javascript":
          return this.replaced_extname = ".js";
        case "css":
          return this.replaced_extname = ".css";
        default:
          throw "no extname type";
      }
    };

    UrlConvert.prototype.set_no_version = function() {
      return this.has_version = false;
    };

    UrlConvert.prototype.set_has_version = function() {
      return this.has_version = true;
    };

    UrlConvert.prototype.to_prd = function(md5) {
      var name, prefix;
      prefix = this.baseuri.replace(this.REPLACE_STRING, "prd");
      if (this.has_version) {
        name = this.fnames[0] + "@" + md5 + this.replaced_extname;
      } else {
        name = this.fnames[0] + this.replaced_extname;
      }
      return syspath.join(prefix, name);
    };

    UrlConvert.prototype.to_dev = function() {
      var name, prefix;
      prefix = this.baseuri.replace(this.REPLACE_STRING, "dev");
      if (this.has_version) {
        name = this.fnames[0] + "@dev" + this.replaced_extname;
      } else {
        name = this.fnames[0] + this.replaced_extname;
      }
      return syspath.join(prefix, name);
    };

    UrlConvert.prototype.to_src = function() {
      var name, prefix;
      prefix = this.baseuri.replace(this.REPLACE_STRING, "src");
      name = this.fnames[0] + this.replaced_extname;
      return syspath.join(prefix, name);
    };

    UrlConvert.prototype.to_ver = function() {
      var name, prefix;
      prefix = this.baseuri.replace(this.REPLACE_STRING, "ver");
      name = this.fnames[0] + this.replaced_extname + ".ver";
      return syspath.join(prefix, name);
    };

    return UrlConvert;

  })();

  UrlConvert.PRODUCTION_REGEX = /\/prd\//;

  exports.UrlConvert = UrlConvert;

  exports.proc = utilproc = {
    npmbin: function(cmdname) {
      var p;
      p = utilpath.join(__dirname, '..', 'node_modules', '.bin', cmdname);
      if (utilsys.isWindows) {
        p = p + ".cmd";
      }
      return p;
    },
    exec: function(cmd) {
      var _this = this;
      return child_process.exec(cmd, function(error, stdout, stderr) {
        if (error) {
          return utillogger.error(error);
        }
      });
    },
    setImmediate: function(callback) {
      var fn;
      fn = typeof setImmediate === 'function' ? setImmediate : process.nextTick;
      return fn(callback);
    },
    spawn: function(cmd, args, cb, options) {
      var r;
      r = child_process.spawn(cmd, args || [], _.extend({
        cwd: process.cwd,
        env: process.env
      }, options || {}));
      r.stderr.pipe(process.stderr, {
        end: false
      });
      r.stdout.pipe(process.stdout, {
        end: false
      });
      return r.on('exit', function(code) {
        return cb(code);
      });
    },
    requireScript: function(path, ctx) {
      var Module, code, context, m, mod;
      if (ctx == null) {
        ctx = {};
      }
      Module = require('module');
      mod = new Module(path);
      context = _.extend({}, global, ctx);
      context.module = mod;
      context.__filename = path;
      context.__dirname = syspath.dirname(path);
      context.require = function(path) {
        return mod.require(path);
      };
      context.exports = context.module.exports;
      code = new Reader().read(path);
      switch (syspath.extname(path)) {
        case ".js":
          code = code;
          break;
        case ".vmjs":
          code = code;
          break;
        case ".coffee":
          code = coffee.compile(code);
          break;
        default:
          throw "没有正确的自动化脚本解析器 " + path;
      }
      m = vm.createScript(code);
      m.runInNewContext(context);
      return context.module.exports;
    }
  };

  utilproc.run = utilproc.spawn;

  exports.sys = utilsys = {
    isWindows: process.platform === 'win32'
  };

  exports.http = utilhttp = {
    get: function(url, cb) {
      var opts;
      if (typeof url === 'object') {
        opts = url;
      } else {
        opts = {
          url: url
        };
      }
      utillogger.log("fekit " + (sty.red('http')) + " " + (sty.green('GET')) + " " + opts.url);
      return request(opts, cb);
    },
    put: function(url, filepath_or_formdata, formdata, cb) {
      var form, k, r, v;
      utillogger.log("fekit " + (sty.red('http')) + " " + (sty.green('PUT')) + " " + url);
      if (arguments.length === 4 && typeof filepath_or_formdata === 'string' && typeof formdata === 'object' && typeof cb === 'function') {
        r = request.put(url, function(err, res, body) {
          return cb(err, body, res);
        });
        form = r.form();
        for (k in formdata) {
          v = formdata[k];
          form.append(k, v);
        }
        return form.append('file', fs.createReadStream(filepath_or_formdata));
      } else if (arguments.length === 3) {
        cb = formdata;
        if (typeof filepath_or_formdata === 'string') {
          return fs.createReadStream(filepath_or_formdata).pipe(request.put(url, function(err, res, body) {
            return cb(err, body, res);
          }));
        } else if (typeof filepath_or_formdata === 'object') {
          return request.put(url, {
            form: filepath_or_formdata
          }, function(err, res, body) {
            return cb(err, body, res);
          });
        }
      }
    },
    del: function(url, formdata, cb) {
      var opts;
      if (typeof url === 'object') {
        opts = url;
      } else {
        opts = {
          url: url
        };
      }
      if (typeof formdata === 'function') {
        cb = formdata;
        formdata = {};
      }
      opts.method = 'DELETE';
      opts.form = formdata;
      utillogger.log("fekit " + (sty.red('http')) + " " + (sty.green('DELETE')) + " " + url);
      return request(opts, cb);
    }
  };

  exports.logger = utillogger = {
    debug: false,
    setup: function(options) {
      if (options && options.debug) {
        return utillogger.debug = true;
      }
    },
    start: function() {
      return this._tick = new Date();
    },
    stop: function() {
      return (new Date().getTime() - this._tick.getTime()) + 'ms';
    },
    trace: function() {
      if (!utillogger.debug) {
        return;
      }
      return utillogger.to("[TRACE] ", Array.prototype.join.call(arguments, " "));
    },
    error: function() {
      return utillogger.to("[ERROR] ", Array.prototype.join.call(arguments, " "));
    },
    log: function() {
      return utillogger.to("[LOG] ", Array.prototype.join.call(arguments, " "));
    },
    to: function() {
      var n;
      n = Array.prototype.join.call(arguments, "");
      return console.info(n);
    }
  };

  exports.removeBOM = function(txt) {
    if (txt.charAt(0) === "\uFEFF") {
      return txt.substr(1);
    } else {
      return txt;
    }
  };

  exports.exit = exit = function(exitCode) {
    if (process.stdout._pendingWriteReqs || process.stderr._pendingWriteReqs) {
      return utilproc.setImmediate(function() {
        return exit(exitCode);
      });
    } else {
      return process.exit(exitCode);
    }
  };

  exports.tar = {
    pack: function(source, dest, callback) {
      return fs.stat(source, function(err, stat) {
        return utilproc.setImmediate(function() {
          var gzip, ig, props, reader, writer;
          gzip = zlib.createGzip({
            level: 6,
            memLevel: 6
          });
          ig = ignore().addIgnoreFile(syspath.join(source, '.fekitignore'));
          reader = fstream.Reader({
            path: source,
            type: 'Directory',
            depth: 1,
            filter: function(entry) {
              if (this.basename.match(/^fekit_modules$/)) {
                return false;
              }
              if (this.basename.match(/^\..+$/)) {
                return false;
              }
              if (ig.filter([syspath.relative(source, this.path)]).length === 0) {
                return false;
              }
              if (entry.props.type === "Directory") {
                entry.props.mode |= (entry.props.mode >>> 2) & 0x49;
              }
              return true;
            }
          });
          props = {
            noProprietary: false,
            fromBase: true
          };
          writer = fstream.Writer({
            path: dest
          });
          return reader.pipe(tar.Pack(props)).pipe(gzip).pipe(writer.on('close', function() {
            if (typeof callback === 'function') {
              return callback(null);
            }
          }));
        });
      });
    },
    unpack: function(tarfile, dest, callback) {
      return utilproc.setImmediate(function() {
        return fstream.Reader({
          path: tarfile,
          type: 'File'
        }).pipe(zlib.createGunzip()).pipe(tar.Extract({
          path: dest
        })).on('end', function() {
          if (typeof callback === 'function') {
            return callback(null);
          }
        });
      });
    }
  };

  exports.async = utilasync = {
    series: function(list, iter, done) {
      var item, _i, _len, _list, _tmp;
      _list = [];
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        item = list[_i];
        _tmp = function(item) {
          return function(seriesCallback) {
            return iter(item, seriesCallback);
          };
        };
        _list.push(_tmp(item));
      }
      return async.series(_list, done);
    }
  };

  exports._ = _;

  _.compactObject = function(o) {
    _.each(o, function(v, k) {
      if (v === null) {
        return delete o[k];
      }
    });
    return o;
  };

  exports.extend = function() {
    var list;
    list = [].concat(_.map(arguments, function(i) {
      return _.compactObject(_.extend({}, i));
    }));
    return _.extend.apply(_, list);
  };

  exports.version = utilfile.io.readJSON(syspath.join(__dirname, "../package.json")).version;

  exports.getCurrentEnvironment = function(options) {
    var type;
    type = 'prd';
    if (options.environment) {
      type = options.environment;
    } else if (process.env['FEKIT_ENVIRONMENT']) {
      type = process.env['FEKIT_ENVIRONMENT'];
    }
    type = type.toLowerCase();
    switch (type) {
      case 'prd':
        return type;
      case 'beta':
        return type;
      case 'dev':
        return type;
      case 'local':
        return type;
      default:
        return utillogger.error("获取当前 environment 配置出错(" + type + ") , 值必须为`local`,`dev`,`beta`或`prd`其中之一");
    }
  };

  exports.replaceEnvironmentConfig = function(type, source, config) {
    var reg;
    config = config || {};
    reg = /\/\*\[([^\]]+?)\]\*\//ig;
    return source.replace(reg, function($0, $1) {
      if (config[$1] !== null && typeof config[$1] !== 'undefined') {
        switch (type) {
          case "js":
            return util.inspect(config[$1]);
          default:
            return config[$1];
        }
      } else {
        return "";
      }
    });
  };

  exports.md5 = function(data) {
    var hash;
    data = new Buffer(data);
    hash = crypto.createHash('md5');
    hash.update(data);
    return hash.digest('hex');
  };

}).call(this);
