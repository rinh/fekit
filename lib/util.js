// Generated by CoffeeScript 1.7.1
(function() {
  var FekitConfig, Reader, UrlConvert, Writer, async, child_process, cjson, coffee, exit, fs, fstream, mkdirp, ncp, request, rimraf, sty, syspath, tar, utilarray, utilasync, utilconfig, utilfile, utilhttp, utillogger, utilpath, utilproc, utilsys, vm, yaml, zlib, _, _closest, _closest_dir, _runCode, _watch;

  request = require('request');

  rimraf = require('rimraf');

  async = require('async');

  child_process = require('child_process');

  syspath = require('path');

  fs = require('fs');

  mkdirp = require('mkdirp');

  yaml = require('yaml');

  cjson = require('cjson');

  _ = require('underscore');

  vm = require('vm');

  coffee = require('coffee-script');

  ncp = require('ncp').ncp;

  tar = require('rinh-node-tar');

  fstream = require('fstream');

  zlib = require('zlib');

  sty = require('sty');

  exports.array = utilarray = {
    clear_empty: function(array) {
      var i, n, _i, _len;
      n = [];
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        i = array[_i];
        if (i !== "" || i !== null) {
          n.push(i);
        }
      }
      return n;
    }
  };

  _closest = function(p, findfilename, filterFunc) {
    var dir, file, files, _i, _len;
    if (p === "/" || (process.platform === "win32" && p.match(/^[a-zA-Z]:(\\|\/)?$/))) {
      return null;
    }
    if (utilpath.is_directory(p)) {
      dir = p;
    } else {
      dir = syspath.dirname(p);
    }
    files = fs.readdirSync(dir);
    for (_i = 0, _len = files.length; _i < _len; _i++) {
      file = files[_i];
      if (file === findfilename) {
        if (filterFunc) {
          if (filterFunc(utilpath.join(dir, file))) {
            return dir;
          }
        } else {
          return dir;
        }
      }
    }
    return _closest(syspath.dirname(dir), findfilename, filterFunc);
  };

  _closest_dir = function(p, finddirname, filterFunc) {
    var dir, file, files, _i, _len;
    if (p === "/" || (process.platform === "win32" && p.match(/^[a-zA-Z]:(\\|\/)?$/))) {
      return null;
    }
    if (utilpath.is_directory(p)) {
      dir = p;
    } else {
      dir = syspath.dirname(p);
    }
    files = fs.readdirSync(dir);
    for (_i = 0, _len = files.length; _i < _len; _i++) {
      file = files[_i];
      if (file === finddirname && utilpath.is_directory(file)) {
        if (filterFunc) {
          if (filterFunc(file)) {
            return dir;
          }
        } else {
          return dir;
        }
      }
    }
    return _closest_dir(syspath.dirname(dir), finddirname, filterFunc);
  };

  exports.path = utilpath = {
    dirname: syspath.dirname,
    basename: syspath.basename,
    resolve: syspath.resolve,
    join: function() {
      var arr, i;
      arr = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = arguments.length; _i < _len; _i++) {
          i = arguments[_i];
          _results.push(typeof i === 'undefined' ? '' : i);
        }
        return _results;
      }).apply(this, arguments);
      return syspath.join.apply(syspath, arr);
    },
    fname: function(path) {
      return syspath.basename(path).replace(syspath.extname(path), '');
    },
    get_user_home: function() {
      return process.env[process.platform === 'win32' ? 'USERPROFILE' : 'HOME'];
    },
    closest: function(path, findfilename, is_directory, filterFunc) {
      if (is_directory) {
        return _closest_dir(path, findfilename, filterFunc);
      } else {
        return _closest(path, findfilename, filterFunc);
      }
    },
    SEPARATOR: syspath.sep,
    is_root: function(path) {
      var p;
      if (process.platform === 'win32') {
        p = path.replace(syspath.sep, '');
        return /^[a-z]:\s*$/i.test(p);
      } else {
        return syspath.sep === path;
      }
    },
    exists: function(path) {
      if (fs.existsSync) {
        return fs.existsSync(path);
      }
      if (syspath.existsSync) {
        return syspath.existsSync(path);
      }
    },
    split_path: function(path, ext_list) {
      var ext, parts;
      if (~path.indexOf("/")) {
        parts = path.split("/");
      } else if (~path.indexOf("\\")) {
        parts = path.split("\\");
      } else {
        parts = path.split(".");
      }
      parts = utilarray.clear_empty(parts);
      ext = "." + parts[parts.length - 1];
      if (~ext_list.indexOf(ext)) {
        parts = parts.slice(0, parts.length - 1);
        parts[parts.length - 1] = parts[parts.length - 1] + ext;
      }
      return parts;
    },
    is_directory: function(path) {
      var err, stats;
      try {
        stats = fs.statSync(path);
        return stats.isDirectory();
      } catch (_error) {
        err = _error;
        throw err;
        return false;
      }
    },
    is_normalize_dirname: function(path) {
      return (/[\w-\.\s]+/i.test(path)) && (path !== '.') && (path !== '..') && (path !== '.svn') && (path !== '.git');
    },
    each_directory: function(path, cb, is_recursion) {
      var f, list, p, _i, _len, _results;
      if (!utilpath.is_directory(path)) {
        path = syspath.dirname(path);
      }
      list = fs.readdirSync(path);
      _results = [];
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        f = list[_i];
        p = syspath.join(path, f);
        if (!is_recursion) {
          if (utilpath.is_normalize_dirname(f) && !utilpath.is_directory(p)) {
            _results.push(cb(p));
          } else {
            _results.push(void 0);
          }
        } else {
          if (utilpath.is_normalize_dirname(f)) {
            if (!utilpath.is_directory(p)) {
              _results.push(cb(p));
            } else {
              _results.push(utilpath.each_directory(p, cb, is_recursion));
            }
          } else {
            _results.push(void 0);
          }
        }
      }
      return _results;
    },
    existsFiles: function(root, filenames) {
      var name, p, _i, _len;
      for (_i = 0, _len = filenames.length; _i < _len; _i++) {
        name = filenames[_i];
        p = syspath.join(root, name);
        if (utilpath.exists(p)) {
          return p;
        }
      }
      throw "找不到文件列表中的任一文件 " + root + " 下的 [" + (filenames.join()) + "]";
    },
    is_absolute_path: function(path) {
      return (process.platform === "win32" && p.match(/^[a-zA-Z]:(\\|\/)?$/)) || path.charAt(0) === "/";
    }
  };

  Reader = (function() {
    function Reader() {}

    Reader.prototype.readlines = function(filepath) {
      return this.read(filepath).toString().split(utilfile.NEWLINE);
    };

    Reader.prototype.read = function(filepath) {
      if (!utilpath.exists(filepath)) {
        throw "找不到文件 " + filepath;
      }
      return fs.readFileSync(filepath).toString().replace(/\r\n/g, '\n');
    };

    Reader.prototype.readJSON = function(filepath) {
      var err;
      try {
        return cjson.load(filepath);
      } catch (_error) {
        err = _error;
        throw "解析 " + filepath + " 时出现错误, 请检查该文件, 该文件必须是标准JSON格式";
      }
    };

    Reader.prototype.readYAML = function(filepath) {
      var code, err, line, lines, s, _i, _len;
      lines = this.readlines(filepath);
      s = [];
      for (_i = 0, _len = lines.length; _i < _len; _i++) {
        line = lines[_i];
        if (/.*?:\s*[^\s]+/.test(line)) {
          s.push(line.replace(/^(.*?):\s*(.*?)\s*$/, "$1: '$2'"));
        } else {
          s.push(line);
        }
      }
      code = s.join(utilfile.NEWLINE);
      try {
        return yaml["eval"](code);
      } catch (_error) {
        err = _error;
        throw "解析 " + filepath + " 时出现错误, 请检查该文件, 该文件必须是标准YAML格式";
      }
    };

    return Reader;

  })();

  Writer = (function() {
    function Writer() {}

    Writer.prototype.write = function(filepath, content) {
      if (!utilpath.exists(syspath.dirname(filepath))) {
        mkdirp.sync(syspath.dirname(filepath));
      }
      return fs.writeFileSync(filepath, content);
    };

    return Writer;

  })();

  exports.file = utilfile = {};

  utilfile.reader = Reader;

  utilfile.writer = Writer;

  utilfile.io = _.extend({}, Reader.prototype, Writer.prototype);

  utilfile.NEWLINE = '\n';

  _watch = function(path, cb) {
    var f, list, p, watcher, _i, _len, _results;
    if (!utilpath.is_directory(path)) {
      path = syspath.dirname(path);
    }
    watcher = fs.watch(path, cb);
    watcher.on('error', function(e) {
      watcher.close();
      return watcher = null;
    });
    list = fs.readdirSync(path);
    _results = [];
    for (_i = 0, _len = list.length; _i < _len; _i++) {
      f = list[_i];
      p = syspath.join(path, f);
      if (utilpath.is_normalize_dirname(f) && utilpath.is_directory(p)) {
        _results.push(_watch(p, cb));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  utilfile.watch = function(dest, cb, crashCB) {
    return _watch(dest, cb, crashCB);
  };

  utilfile.copy = function(srcFile, destFile) {
    var BUF_LENGTH, buff, bytesRead, fdr, fdw, pos;
    BUF_LENGTH = 64 * 1024;
    buff = new Buffer(BUF_LENGTH);
    fdr = fs.openSync(srcFile, 'r');
    fdw = fs.openSync(destFile, 'w');
    bytesRead = 1;
    pos = 0;
    while (bytesRead > 0) {
      bytesRead = fs.readSync(fdr, buff, 0, BUF_LENGTH, pos);
      fs.writeSync(fdw, buff, 0, bytesRead);
      pos += bytesRead;
    }
    fs.closeSync(fdr);
    return fs.closeSync(fdw);
  };

  utilfile.cpr = function(src, dest, cb) {
    return ncp(src, dest, cb);
  };

  utilfile.rmrf = function(dest, cb) {
    if (cb) {
      return rimraf(dest, cb);
    } else {
      return rimraf.sync(dest);
    }
  };

  utilfile.mkdirp = mkdirp.sync;

  utilfile.findify = function(path_without_extname, ext_list) {
    var ext, list, path, _i, _len;
    list = [""].concat(ext_list);
    for (_i = 0, _len = list.length; _i < _len; _i++) {
      ext = list[_i];
      path = path_without_extname + ext;
      if (utilpath.exists(path) && !utilpath.is_directory(path)) {
        return path;
      }
    }
    return null;
  };


  /*
      {
          // 别名配置
          "alias" : {
              "core" : "./src/scripts/core"
          } ,
          // 导出配置 , 默认是以src为根目录
          // 输出至 dev 就变为 scripts/page-a@dev.js
          // 输出至 prd 就变为 scripts/page-a@(md5).js
          "export" : [
              "scripts/page-a.js"
          ] ,
          // sync 使用的配置
          "dev" : {
              "host" : "127.0.0.1"
              "path" : "/home/q/"
          }
      }
   */

  FekitConfig = (function() {
    function FekitConfig(baseUri) {
      var err;
      this.baseUri = baseUri;
      this.fekit_config_filename = "fekit.config";
      this.fekit_root_dirname = utilpath.closest(this.baseUri, this.fekit_config_filename);
      this.fekit_config_path = syspath.join(this.fekit_root_dirname || "", this.fekit_config_filename);
      try {
        this.root = new utilfile.reader().readJSON(this.fekit_config_path);
        if (!this.getAlias()) {
          this.root.alias = {};
        }
      } catch (_error) {
        err = _error;
        if (utilpath.exists(this.fekit_config_path)) {
          throw "" + this.fekit_config_filename + " 解析失败, 请确认该文件格式是否符合正确的JSON格式";
        } else {
          this.root = {
            "alias": {},
            "export": []
          };
        }
      }
    }

    FekitConfig.prototype.getAlias = function(name) {
      var _ref, _ref1;
      if (!name) {
        return this.root.alias || this.root.lib;
      } else {
        return ((_ref = this.root.alias) != null ? _ref[name] : void 0) || ((_ref1 = this.root.lib) != null ? _ref1[name] : void 0);
      }
    };

    FekitConfig.prototype.getExportFileConfig = function(fullpath) {
      var n;
      n = null;
      this.each_export_files(function(path, parents, opts) {
        if (path === fullpath) {
          return n = opts;
        }
      });
      return n;
    };

    FekitConfig.prototype.each_export_files = function(cb) {
      var file, list, opts, parents, path, _i, _len, _results;
      list = this.root["export"] || [];
      _results = [];
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        file = list[_i];
        opts = {};
        if (_.isObject(file)) {
          path = syspath.join(this.fekit_root_dirname, "src", file.path);
          parents = _.map(file.parents || [], (function(_this) {
            return function(ppath) {
              return syspath.join(_this.fekit_root_dirname, "src", ppath);
            };
          })(this));
          opts = file;
          opts.partial_path = file.path;
        } else {
          path = syspath.join(this.fekit_root_dirname, "src", file);
          parents = [];
          opts.path = path;
          opts.partial_path = file;
        }
        if (utilpath.exists(path)) {
          _results.push(cb(path, parents, opts));
        } else {
          _results.push(utillogger.error("找不到文件 " + path));
        }
      }
      return _results;
    };

    FekitConfig.prototype.each_export_files_async = function(cb, doneCallback) {
      var file, list, tasks, _i, _len, _tmp;
      tasks = [];
      list = this.root["export"] || [];
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        file = list[_i];
        _tmp = (function(_this) {
          return function(file) {
            return function(seriesCallback) {
              var opts, parents, path;
              opts = {};
              if (_.isObject(file)) {
                path = syspath.join(_this.fekit_root_dirname, "src", file.path);
                parents = _.map(file.parents || [], function(ppath) {
                  return syspath.join(_this.fekit_root_dirname, "src", ppath);
                });
                opts = file;
                opts.partial_path = file.path;
              } else {
                path = syspath.join(_this.fekit_root_dirname, "src", file);
                parents = [];
                opts.path = file;
                opts.partial_path = file;
              }
              if (utilpath.exists(path)) {
                return cb(path, parents, opts, seriesCallback);
              } else {
                utillogger.error("找不到文件 " + path);
                return utilproc.setImmediate(seriesCallback);
              }
            };
          };
        })(this);
        tasks.push(_tmp(file));
      }
      return async.series(tasks, function(err) {
        if (err) {
          throw err;
        }
        return doneCallback();
      });
    };

    FekitConfig.prototype.findExportFile = function(filepath, cb) {
      var file, hit, list, parents, path, _i, _len;
      list = this.root["export"] || [];
      hit = false;
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        file = list[_i];
        if (_.isObject(file)) {
          path = syspath.join(this.fekit_root_dirname, "src", file.path);
          parents = _.map(file.parents || [], (function(_this) {
            return function(ppath) {
              return syspath.join(_this.fekit_root_dirname, "src", ppath);
            };
          })(this));
        } else {
          path = syspath.join(this.fekit_root_dirname, "src", file);
          parents = [];
        }
        if (filepath === path) {
          hit = true;
          cb(filepath, parents);
        }
      }
      if (!hit) {
        return cb(null, []);
      }
    };

    FekitConfig.prototype.doScript = function(type, context) {
      var ctx, path, _ref, _ref1;
      ctx = context || {};
      ctx.path = utilpath;
      ctx.io = {
        reader: new Reader(),
        writer: new Writer()
      };
      path = (_ref = this.root) != null ? (_ref1 = _ref.scripts) != null ? _ref1[type] : void 0 : void 0;
      if (!path) {
        return;
      }
      path = syspath.join(this.fekit_root_dirname, path);
      if (!utilpath.exists(path)) {
        return;
      }
      utillogger.log("检测到自动脚本 " + type + " , 开始执行.");
      _runCode(path, ctx);
      return utillogger.log("自动脚本 " + type + " , 执行完毕.");
    };

    return FekitConfig;

  })();

  _runCode = function(path, ctx) {
    var Module, code, context, m, mod;
    Module = require('module');
    mod = new Module(path);
    context = _.extend({}, global, ctx);
    context.module = mod;
    context.__filename = path;
    context.__dirname = syspath.dirname(path);
    context.require = function(path) {
      return mod.require(path);
    };
    code = new Reader().read(path);
    switch (syspath.extname(path)) {
      case ".js":
        code = code;
        break;
      case ".coffee":
        code = coffee.compile(code);
        break;
      default:
        throw "没有正确的自动化脚本解析器 " + path;
    }
    m = vm.createScript(code);
    return m.runInNewContext(context);
  };

  exports.config = utilconfig = {
    parse: function(baseUri) {
      return new FekitConfig(baseUri);
    },
    createEmptySchema: function() {
      return {
        "compiler": "modular",
        "name": "",
        "version": "",
        "dependencies": {},
        "alias": {},
        "export": []
      };
    }
  };

  UrlConvert = (function() {
    function UrlConvert(uri, root) {
      var baseuri, extname, filename, fnames, _tmp;
      this.uri = uri;
      this.root = root;
      this.REPLACE_STRING = "##REPLACE##";
      if (!this.root) {
        baseuri = this.uri.replace(/[\/\\](dev|prd|src)[\/\\]/, (function(_this) {
          return function($0, $1) {
            return "/" + _this.REPLACE_STRING + "/";
          };
        })(this));
      } else {
        _tmp = (this.uri.replace(this.root, "")).replace(/[\/\\](dev|prd|src)[\/\\]/, (function(_this) {
          return function($0, $1) {
            return "/" + _this.REPLACE_STRING + "/";
          };
        })(this));
        baseuri = syspath.join(this.root, _tmp);
      }
      extname = syspath.extname(baseuri);
      filename = syspath.basename(baseuri, extname);
      baseuri = baseuri.replace(filename + extname, "");
      fnames = filename.split("@");
      this.baseuri = baseuri;
      this.extname = extname;
      this.replaced_extname = extname;
      this.filename = filename;
      this.fnames = fnames;
      this.has_version = true;
    }

    UrlConvert.prototype.set_extname_type = function(type) {
      type = type || "";
      switch (type.toLowerCase()) {
        case "javascript":
          return this.replaced_extname = ".js";
        case "css":
          return this.replaced_extname = ".css";
        default:
          throw "no extname type";
      }
    };

    UrlConvert.prototype.set_no_version = function() {
      return this.has_version = false;
    };

    UrlConvert.prototype.set_has_version = function() {
      return this.has_version = true;
    };

    UrlConvert.prototype.to_prd = function(md5) {
      var name, prefix;
      prefix = this.baseuri.replace(this.REPLACE_STRING, "prd");
      if (this.has_version) {
        name = this.fnames[0] + "@" + md5 + this.replaced_extname;
      } else {
        name = this.fnames[0] + this.replaced_extname;
      }
      return syspath.join(prefix, name);
    };

    UrlConvert.prototype.to_dev = function() {
      var name, prefix;
      prefix = this.baseuri.replace(this.REPLACE_STRING, "dev");
      if (this.has_version) {
        name = this.fnames[0] + "@dev" + this.replaced_extname;
      } else {
        name = this.fnames[0] + this.replaced_extname;
      }
      return syspath.join(prefix, name);
    };

    UrlConvert.prototype.to_src = function() {
      var name, prefix;
      prefix = this.baseuri.replace(this.REPLACE_STRING, "src");
      name = this.fnames[0] + this.replaced_extname;
      return syspath.join(prefix, name);
    };

    UrlConvert.prototype.to_ver = function() {
      var name, prefix;
      prefix = this.baseuri.replace(this.REPLACE_STRING, "ver");
      name = this.fnames[0] + this.replaced_extname + ".ver";
      return syspath.join(prefix, name);
    };

    return UrlConvert;

  })();

  UrlConvert.PRODUCTION_REGEX = /\/prd\//;

  exports.UrlConvert = UrlConvert;

  exports.proc = utilproc = {
    exec: function(cmd) {
      return child_process.exec(cmd, (function(_this) {
        return function(error, stdout, stderr) {
          if (error) {
            return utillogger.error(error);
          }
        };
      })(this));
    },
    setImmediate: function(callback) {
      var fn;
      fn = typeof setImmediate === 'function' ? setImmediate : process.nextTick;
      return fn(callback);
    },
    spawn: function(cmd, args, cb, options) {
      var r;
      r = child_process.spawn(cmd, args || [], _.extend({
        cwd: process.cwd,
        env: process.env
      }, options || {}));
      r.stderr.pipe(process.stderr, {
        end: false
      });
      r.stdout.pipe(process.stdout, {
        end: false
      });
      return r.on('exit', function(code) {
        return cb(code);
      });
    },
    requireScript: function(path, ctx) {
      var Module, code, context, m, mod;
      if (ctx == null) {
        ctx = {};
      }
      Module = require('module');
      mod = new Module(path);
      context = _.extend({}, global, ctx);
      context.module = mod;
      context.__filename = path;
      context.__dirname = syspath.dirname(path);
      context.require = function(path) {
        return mod.require(path);
      };
      context.exports = {};
      code = new Reader().read(path);
      switch (syspath.extname(path)) {
        case ".js":
          code = code;
          break;
        case ".coffee":
          code = coffee.compile(code);
          break;
        default:
          throw "没有正确的自动化脚本解析器 " + path;
      }
      m = vm.createScript(code);
      m.runInNewContext(context);
      return context.exports;
    }
  };

  utilproc.run = utilproc.spawn;

  exports.sys = utilsys = {
    isWindows: process.platform === 'win32'
  };

  exports.http = utilhttp = {
    get: function(url, cb) {
      var opts;
      if (typeof url === 'object') {
        opts = url;
      } else {
        opts = {
          url: url
        };
      }
      utillogger.log("fekit " + (sty.red('http')) + " " + (sty.green('GET')) + " " + opts.url);
      return request(opts, cb);
    },
    put: function(url, filepath_or_formdata, formdata, cb) {
      var form, k, r, v;
      utillogger.log("fekit " + (sty.red('http')) + " " + (sty.green('PUT')) + " " + url);
      if (arguments.length === 4 && typeof filepath_or_formdata === 'string' && typeof formdata === 'object' && typeof cb === 'function') {
        r = request.put(url, function(err, res, body) {
          return cb(err, body, res);
        });
        form = r.form();
        for (k in formdata) {
          v = formdata[k];
          form.append(k, v);
        }
        return form.append('file', fs.createReadStream(filepath_or_formdata));
      } else if (arguments.length === 3) {
        cb = formdata;
        if (typeof filepath_or_formdata === 'string') {
          return fs.createReadStream(filepath_or_formdata).pipe(request.put(url, function(err, res, body) {
            return cb(err, body, res);
          }));
        } else if (typeof filepath_or_formdata === 'object') {
          return request.put(url, {
            form: filepath_or_formdata
          }, function(err, res, body) {
            return cb(err, body, res);
          });
        }
      }
    },
    del: function(url, formdata, cb) {
      var opts;
      if (typeof url === 'object') {
        opts = url;
      } else {
        opts = {
          url: url
        };
      }
      if (typeof formdata === 'function') {
        cb = formdata;
        formdata = {};
      }
      opts.method = 'DELETE';
      opts.form = formdata;
      utillogger.log("fekit " + (sty.red('http')) + " " + (sty.green('DELETE')) + " " + url);
      return request(opts, cb);
    }
  };

  exports.logger = utillogger = {
    debug: false,
    setup: function(options) {
      if (options && options.debug) {
        return utillogger.debug = true;
      }
    },
    start: function() {
      return this._tick = new Date();
    },
    stop: function() {
      return (new Date().getTime() - this._tick.getTime()) + 'ms';
    },
    trace: function() {
      if (!utillogger.debug) {
        return;
      }
      return utillogger.to("[TRACE] ", Array.prototype.join.call(arguments, " "));
    },
    error: function() {
      return utillogger.to("[ERROR] ", Array.prototype.join.call(arguments, " "));
    },
    log: function() {
      return utillogger.to("[LOG] ", Array.prototype.join.call(arguments, " "));
    },
    to: function() {
      var n;
      n = Array.prototype.join.call(arguments, "");
      return console.info(n);
    }
  };

  exports.exit = exit = function(exitCode) {
    if (process.stdout._pendingWriteReqs || process.stderr._pendingWriteReqs) {
      return utilproc.setImmediate(function() {
        return exit(exitCode);
      });
    } else {
      return process.exit(exitCode);
    }
  };

  exports.tar = {
    pack: function(source, dest, callback) {
      return fs.stat(source, function(err, stat) {
        return utilproc.setImmediate(function() {
          var gzip, props, reader, writer;
          gzip = zlib.createGzip({
            level: 6,
            memLevel: 6
          });
          reader = fstream.Reader({
            path: source,
            type: 'Directory',
            depth: 1,
            filter: function(entry) {
              if (this.basename.match(/^fekit_modules$/)) {
                return false;
              }
              if (this.basename.match(/^\..+$/)) {
                return false;
              }
              if (entry.props.type === "Directory") {
                entry.props.mode |= (entry.props.mode >>> 2) & 0x49;
              }
              return true;
            }
          });
          props = {
            noProprietary: false,
            fromBase: true
          };
          writer = fstream.Writer({
            path: dest
          });
          return reader.pipe(tar.Pack(props)).pipe(gzip).pipe(writer.on('close', function() {
            if (typeof callback === 'function') {
              return callback(null);
            }
          }));
        });
      });
    },
    unpack: function(tarfile, dest, callback) {
      return utilproc.setImmediate(function() {
        return fstream.Reader({
          path: tarfile,
          type: 'File'
        }).pipe(zlib.createGunzip()).pipe(tar.Extract({
          path: dest
        })).on('end', function() {
          if (typeof callback === 'function') {
            return callback(null);
          }
        });
      });
    }
  };

  exports.async = utilasync = {
    series: function(list, iter, done) {
      var item, _i, _len, _list, _tmp;
      _list = [];
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        item = list[_i];
        _tmp = function(item) {
          return function(seriesCallback) {
            return iter(item, seriesCallback);
          };
        };
        _list.push(_tmp(item));
      }
      return async.series(_list, done);
    }
  };

  exports.version = utilfile.io.readJSON(syspath.join(__dirname, "../package.json")).version;

}).call(this);
