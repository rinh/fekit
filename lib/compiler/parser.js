// Generated by CoffeeScript 1.4.0
(function() {
  var Compiler, convertRegexp, find_line_from_str, fs, getVal, is_line_end, parse, _is_break;

  fs = require('fs');

  getVal = function(regexpResult) {
    var idx, r, _i, _len;
    for (idx = _i = 0, _len = regexpResult.length; _i < _len; idx = ++_i) {
      r = regexpResult[idx];
      if (idx === 0) {
        continue;
      }
      if (r) {
        return r;
      }
    }
  };

  convertRegexp = function(str, flag) {
    str = str.replace(/\s/g, '').replace('{space}', ' ');
    return new RegExp(str, flag);
  };

  _is_break = function(str, idx) {
    if (idx < 0) {
      return true;
    }
    if (idx > str.length) {
      return true;
    }
    if (str.charAt(idx) === '\n') {
      return true;
    }
    return false;
  };

  exports.find_line_from_str = find_line_from_str = function(str, index, is_fullline) {
    var end, start;
    start = index;
    end = index;
    while (!_is_break(str, start)) {
      start--;
    }
    if (is_fullline) {
      while (!_is_break(str, end)) {
        end++;
      }
      return str.substring(start, end).replace(/\n/g, '');
    } else {
      return str.substring(start, index).replace(/\n/g, '');
    }
  };

  exports.is_line_end = is_line_end = function(str, index) {
    var s;
    s = "";
    while (!_is_break(str, index)) {
      s += str[index];
      index++;
    }
    return s.replace(/\s*/g, '') === "";
  };

  parse = function(str) {
    var end, prefix_comment, r, regstr, result, start, _line;
    result = [];
    regstr = convertRegexp("(\n    ?: [{space}]*require\\s*\\(\\s*'([^']+)'\\s*\\)\n    |  [{space}]*require\\s*\\(\\s*\"([^\"]+)\"\\s*\\)\n    |  [{space}]*@import\\s+url\\s*\\(\\s*'([^']+)'\\s*\\)\n    |  [{space}]*@import\\s+url\\s*\\(\\s*\"([^\"]+)\"\\s*\\)\n    |  [{space}]*@import\\s+url\\s*\\(\\s*([^\\)]+)\\s*\\)\n)\n[{space};]*", "g");
    prefix_comment = convertRegexp("^\\s*\\/\\/");
    start = end = 0;
    while ((r = regstr.exec(str)) !== null) {
      end = regstr.lastIndex - r[0].length;
      result.push(str.substring(start, end));
      _line = find_line_from_str(str, end, false);
      if (prefix_comment.test(_line) || _line.charAt(_line.length - 1) === '.') {
        result.push(r[0]);
      } else {
        result.push({
          type: 'require',
          value: getVal(r),
          is_line_end: is_line_end(str, regstr.lastIndex)
        });
      }
      start = regstr.lastIndex;
    }
    result.push(str.substring(start));
    return result;
  };

  Compiler = (function() {

    function Compiler(ast) {
      this.ast = ast;
    }

    Compiler.prototype.print = function() {
      var i, line, list, type;
      list = [];
      i = 0;
      while (i < this.ast.length) {
        line = this.ast[i];
        if (typeof line === "string") {
          list.push(line);
        } else {
          type = line.type;
          if (this["print_" + type]) {
            list.push(this["print_" + type](line));
          } else {
            list.push(this["print_"](line));
          }
        }
        i++;
      }
      return list.join("");
    };

    Compiler.prototype.find = function(type, cb) {
      var i, line, list;
      list = [];
      type = (type || "").toLowerCase();
      i = 0;
      while (i < this.ast.length) {
        line = this.ast[i];
        if (line.type === type) {
          cb && cb(line);
          list.push(line);
        }
        i++;
      }
      return list;
    };

    Compiler.prototype.defineType = function(type, func) {
      type = (type || "").toLowerCase();
      return this["print_" + type] = func;
    };

    Compiler.prototype.print_ = function(line) {
      if (typeof line === "string") {
        return line;
      } else {
        return JSON.stringify(line);
      }
    };

    return Compiler;

  })();

  exports.parseAST = function(source) {
    var ast, compiler;
    ast = parse(source);
    compiler = new Compiler(ast);
    return compiler;
  };

}).call(this);
