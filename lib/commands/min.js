// Generated by CoffeeScript 1.7.1
(function() {
  var compiler, jsp, md5, minCode, pro, process_directory, process_single_file, save_versions_mapping, syspath, uglifycss, utils;

  syspath = require('path');

  compiler = require("../compiler/compiler");

  utils = require("../util");

  md5 = require("MD5");

  uglifycss = require("uglifycss");

  jsp = require("uglify-js").parser;

  pro = require("uglify-js").uglify;

  exports.usage = "压缩/混淆项目文件";

  exports.set_options = function(optimist) {
    optimist.alias('f', 'filename');
    optimist.describe('f', '指定编译某个文件, 而不是当前目录. 处理后默认将文件放在同名目录下并加后缀 min');
    optimist.alias('o', 'output');
    optimist.describe('o', '指定单个文件编译的输出位置');
    optimist.alias('n', 'nopack');
    optimist.describe('n', '不进行压缩处理');
    optimist.alias('c', 'noSplitCSS');
    optimist.describe('c', '不分割 css 为多行形式，默认分割');
    optimist.alias('v', 'onlyVersionFile');
    optimist.describe('v', '在 /ver 目录中只生成 version 文件');
    optimist.alias('m', 'onlyMappingFile');
    return optimist.describe('m', '在 /ver 目录中只生成 mapping 文件');
  };

  process_directory = function(options) {
    var conf, script_global, vertype;
    utils.file.rmrf(syspath.join(options.cwd, './ver/'));
    utils.file.rmrf(syspath.join(options.cwd, './prd/'));
    vertype = 0;
    if (options.onlyMappingFile && options.onlyVersionFile) {
      vertype = 0;
    } else if (!options.onlyMappingFile && options.onlyVersionFile) {
      vertype = 1;
    } else if (options.onlyMappingFile && !options.onlyVersionFile) {
      vertype = 2;
    }
    script_global = {
      EXPORT_LIST: [],
      EXPORT_MAP: {}
    };
    conf = utils.config.parse(options.cwd);
    conf.each_export_files(function(srcpath, parents, opts) {
      var iter;
      iter = {
        url: srcpath,
        path: syspath.join("src", opts.partial_path)
      };
      script_global.EXPORT_LIST.push(iter);
      return script_global.EXPORT_MAP[opts.partial_path] = iter;
    });
    conf.doScript("premin", script_global);
    return conf.each_export_files_async(function(srcpath, parents, opts, seriesCallback) {
      var start, urlconvert, writer, _done;
      start = new Date();
      utils.logger.log("正在处理 " + srcpath);
      urlconvert = new utils.UrlConvert(srcpath, options.cwd);
      if (opts.no_version) {
        urlconvert.set_no_version();
      }
      urlconvert.set_extname_type(compiler.getContentType(srcpath));
      writer = new utils.file.writer();
      _done = function(err, source) {
        var dest, final_code, md5code, _ref, _ref1;
        if (err) {
          utils.logger.error(err.toString());
          utils.exit(1);
          return;
        }
        final_code = minCode(urlconvert.replaced_extname, source, options, conf.root);
        if (final_code !== null) {
          md5code = md5(final_code);
          dest = urlconvert.to_prd(md5code);
          writer.write(dest, final_code);
          if (vertype === 0 || vertype === 1) {
            writer.write(urlconvert.to_ver(), opts.no_version ? "" : md5code);
          }
          if ((_ref = script_global.EXPORT_MAP[opts.partial_path]) != null) {
            _ref.ver = opts.no_version ? "" : md5code;
          }
          if ((_ref1 = script_global.EXPORT_MAP[opts.partial_path]) != null) {
            _ref1.minpath = dest.replace(options.cwd, "");
          }
          utils.logger.log("已经处理 [" + (new Date().getTime() - start.getTime()) + "ms] " + srcpath + "  ==> " + dest);
        } else {
          utils.logger.error("编译出现错误 " + srcpath);
        }
        return seriesCallback();
      };
      return compiler.compile(srcpath, {
        dependencies_filepath_list: parents
      }, _done);
    }, function() {
      if (vertype === 0 || vertype === 2) {
        save_versions_mapping(syspath.join(options.cwd, './ver/versions.mapping'), script_global.EXPORT_MAP);
      }
      conf.doScript("postmin", script_global);
      return utils.logger.log("DONE.");
    });
  };

  save_versions_mapping = function(mapping_file_path, mapping) {
    var k, str, v;
    str = [];
    for (k in mapping) {
      v = mapping[k];
      str.push(k.replace(/\\/g, "/") + '#' + v.ver);
    }
    return utils.file.io.write(mapping_file_path, str.join('\n'));
  };

  process_single_file = function(options) {
    var dest, extname, fname, replaced_extname, srcpath;
    if (utils.path.is_absolute_path(options.filename)) {
      srcpath = options.filename;
    } else {
      srcpath = syspath.join(options.cwd, options.filename);
    }
    extname = syspath.extname(srcpath);
    switch (compiler.getContentType(srcpath)) {
      case "javascript":
        replaced_extname = ".js";
        break;
      case "css":
        replaced_extname = ".css";
    }
    fname = syspath.basename(srcpath);
    if (options.output) {
      if (utils.path.exists(options.output) && utils.path.is_directory(options.output)) {
        dest = utils.path.join(options.output, fname.replace(extname, ".min" + replaced_extname));
      } else {
        dest = options.output;
      }
    } else {
      dest = srcpath.replace(extname, ".min" + replaced_extname);
    }
    return compiler.compile(srcpath, function(err, source) {
      var final_code;
      if (err) {
        return utils.logger.error(err);
      }
      final_code = minCode(replaced_extname, source, options);
      if (final_code !== null) {
        new utils.file.writer().write(dest, final_code);
        utils.logger.log("已经处理  " + srcpath + "  ==> " + dest);
      } else {
        utils.logger.error("编译出现错误 " + srcpath);
      }
      return utils.logger.log("DONE.");
    });
  };

  exports.minCode = minCode = function(extname, source, options, fekitconfig) {
    var ast, err, final_code, _ref, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
    if (options == null) {
      options = {};
    }
    if (fekitconfig == null) {
      fekitconfig = {};
    }
    if (options.nopack) {
      return source;
    }
    switch (extname) {
      case ".css":
        if (options.noSplitCSS) {
          final_code = uglifycss.processString(source, fekitconfig != null ? (_ref = fekitconfig.min) != null ? (_ref1 = _ref.config) != null ? _ref1.uglifycss : void 0 : void 0 : void 0);
        } else {
          final_code = uglifycss.processString(source, fekitconfig != null ? (_ref2 = fekitconfig.min) != null ? (_ref3 = _ref2.config) != null ? _ref3.uglifycss : void 0 : void 0 : void 0).replace(/}/g, "}\n");
        }
        break;
      case ".js":
        try {
          ast = jsp.parse(source);
          ast = pro.ast_mangle(ast, fekitconfig != null ? (_ref4 = fekitconfig.min) != null ? (_ref5 = _ref4.config) != null ? (_ref6 = _ref5.uglifyjs) != null ? _ref6.ast_mangle : void 0 : void 0 : void 0 : void 0);
          if (fekitconfig != null ? (_ref7 = fekitconfig.minconfig) != null ? (_ref8 = _ref7.uglifyjs) != null ? _ref8.ast_squeeze : void 0 : void 0 : void 0) {
            ast = pro.ast_squeeze(ast, fekitconfig != null ? (_ref9 = fekitconfig.min) != null ? (_ref10 = _ref9.config) != null ? (_ref11 = _ref10.uglifyjs) != null ? _ref11.ast_squeeze : void 0 : void 0 : void 0 : void 0);
          }
          final_code = pro.gen_code(ast, fekitconfig != null ? (_ref12 = fekitconfig.min) != null ? (_ref13 = _ref12.config) != null ? (_ref14 = _ref13.uglifyjs) != null ? _ref14.gen_code : void 0 : void 0 : void 0 : void 0);
        } catch (_error) {
          err = _error;
          console.info(err);
          return null;
        }
    }
    return final_code;
  };

  exports.run = function(options) {
    utils.logger.log("fekit(" + utils.version + ") min");
    if (options.filename) {
      return process_single_file(options);
    } else {
      return process_directory(options);
    }
  };

}).call(this);
