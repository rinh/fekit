// Generated by CoffeeScript 1.7.1
(function() {
  var charset, compiler, connect, dns, http, listenPort, mime_config, qs, rewrite, setupServer, sysfs, syspath, sysurl, urlrouter, utils, _rewriteObsoleteUrl, _routeRules;

  compiler = require("../compiler/compiler");

  utils = require("../util");

  connect = require("connect");

  rewrite = require("connect-url-rewrite");

  urlrouter = require("urlrouter");

  dns = require("dns");

  http = require("http");

  qs = require("querystring");

  sysurl = require("url");

  syspath = require("path");

  sysfs = require("fs");

  exports.usage = "创建本地服务器, 可以基于其进行本地开发";

  exports.set_options = function(optimist) {
    optimist.alias('p', 'port');
    optimist.describe('p', '服务端口号, 一般无法使用 80 时设置, 并且需要自己做端口转发');
    optimist.alias('r', 'route');
    optimist.describe('r', '路由,将指定路径路由到其它地址, 物理地址需要均在当前执行目录下。格式为 -r 原路径名:路由后的物理目录名');
    optimist.alias('c', 'combine');
    optimist.describe('c', '指定所有文件以合并方式进行加载, 启动该参数则请求文件不会将依赖展开');
    optimist.alias('n', 'noexport');
    optimist.describe('n', '默认情况下，/prd/的请求需要加入export中才可以识别。 指定此选项则可以无视export属性');
    optimist.alias('t', 'transfer');
    optimist.describe('t', '当指定该选项后，会识别以前的 qzz 项目 url');
    optimist.alias('b', 'boost');
    return optimist.describe('b', '可以指定目录进行编译加速。格式为 -b 目录名');
  };

  mime_config = {
    ".js": "application/javascript",
    ".css": "text/css",
    ".html": "text/html"
  };

  charset = ";charset=UTF-8";

  _routeRules = function(options) {
    var list, n, r, rs, _i, _len;
    list = [];
    rs = [].concat(options.route || []);
    for (_i = 0, _len = rs.length; _i < _len; _i++) {
      n = rs[_i];
      r = n.split(":");
      list.push("" + r[0] + " " + r[1]);
      utils.logger.log("已由 " + r[0] + " 转发至 " + r[1]);
    }
    return list;
  };

  _rewriteObsoleteUrl = function(options) {
    var reg;
    reg = /-(\d{16})/;
    if (!options.transfer) {
      return function(req, res, next) {
        return next();
      };
    }
    return function(req, res, next) {
      if (!utils.UrlConvert.PRODUCTION_REGEX.test(req.url)) {
        return next();
      }
      if (req.query.no_dependencies) {
        return next();
      }
      if (reg.test(req.url)) {
        req.url = req.url.replace(reg, '@$1');
      }
      return next();
    };
  };

  setupServer = function(options) {
    var ROOT, app, combine, fekitRouter, no_combine;
    ROOT = options.cwd;
    no_combine = function(path, parents, host, params, doneCallback) {
      var conf, ctx, custom_script, custom_script_path, port, render_func, _ref, _ref1;
      if (params["no_dependencies"] === "true") {
        return compiler.compile(path, {
          dependencies_filepath_list: parents,
          no_dependencies: true,
          root_module_path: params["root"]
        }, doneCallback);
      } else {
        conf = utils.config.parse(path);
        custom_script = (_ref = conf.root) != null ? (_ref1 = _ref.development) != null ? _ref1.custom_render_dependencies : void 0 : void 0;
        custom_script_path = utils.path.join(conf.fekit_root_dirname, custom_script);
        host = host.replace(/:\d+/, "");
        port = options.port && options.port !== "80" ? ":" + options.port : "";
        if (custom_script && utils.path.exists(custom_script_path)) {
          ctx = utils.proc.requireScript(custom_script_path);
          render_func = function() {
            var partial, _path;
            _path = this.path.getFullPath().replace(ROOT, "").replace(/\\/g, '/').replace('/src/', '/prd/');
            partial = "http://" + host + port + _path + "?no_dependencies=true&root=" + (encodeURIComponent(path));
            return ctx.render({
              type: this.path.getContentType(),
              path: this.path.getFullPath(),
              url: partial,
              base_path: path,
              base_params: params
            });
          };
        } else {
          render_func = function() {
            var partial, _path;
            _path = this.path.getFullPath().replace(ROOT, "").replace(/\\/g, '/').replace('/src/', '/prd/');
            partial = "http://" + host + port + _path + "?no_dependencies=true&root=" + (encodeURIComponent(path));
            switch (this.path.getContentType()) {
              case "javascript":
                return "document.write('<script src=\"" + partial + "\"></script>');";
              case "css":
                return "@import url('" + partial + "');";
            }
          };
        }
        return compiler.compile(path, {
          dependencies_filepath_list: parents,
          render_dependencies: render_func
        }, doneCallback);
      }
    };
    combine = function(path, parents, doneCallback) {
      return compiler.compile(path, {
        dependencies_filepath_list: parents
      }, doneCallback);
    };
    fekitRouter = urlrouter((function(_this) {
      return function(app) {
        app.get(/\/vm\//, function(req, res, next) {
          var ctype, host, srcpath, url, _render;
          host = req.headers['host'];
          url = sysurl.parse(req.url);
          srcpath = syspath.join(ROOT, url.pathname);
          if (utils.path.exists(srcpath) && utils.path.is_directory(srcpath)) {
            next();
            return;
          }
          switch (compiler.getContentType(req.url)) {
            case "javascript":
              ctype = ".js";
              break;
            case "css":
              ctype = ".css";
              break;
            case "html":
              ctype = ".html";
              break;
            default:
              ctype = "";
          }
          res.writeHead(200, {
            'Content-Type': mime_config[ctype] + charset
          });
          if (utils.path.exists(srcpath)) {
            _render = function(err, txt) {
              if (err) {
                res.writeHead(500, {
                  'Content-Type': mime_config[ctype] + charset
                });
                return res.end(err);
              } else {
                return res.end(txt);
              }
            };
            return compiler.compile(srcpath, _render);
          } else {
            return res.end("you must make sure the file " + srcpath + " exists");
          }
        });
        return app.get(utils.UrlConvert.PRODUCTION_REGEX, function(req, res, next) {
          var cache, cachekey, config, ctype, host, is_deps, p, params, srcpath, url, urlconvert, _render;
          host = req.headers['host'];
          url = sysurl.parse(req.url);
          p = syspath.join(ROOT, url.pathname);
          params = qs.parse(url.query);
          is_deps = params["no_dependencies"] === "true";
          if (utils.path.exists(p) && utils.path.is_directory(p)) {
            next();
            return;
          }
          urlconvert = new utils.UrlConvert(p, ROOT);
          srcpath = urlconvert.to_src();
          srcpath = compiler.path.findFileWithoutExtname(srcpath);
          console.info(srcpath);
          utils.logger.trace("由 PRD " + req.url + " 解析至 SRC " + srcpath);
          switch (compiler.getContentType(urlconvert.uri)) {
            case "javascript":
              ctype = ".js";
              break;
            case "css":
              ctype = ".css";
              break;
            default:
              ctype = "";
          }
          res.writeHead(200, {
            'Content-Type': mime_config[ctype] + charset
          });
          cachekey = srcpath + (is_deps ? "_deps" : "");
          cache = compiler.booster.get_compiled_cache(cachekey);
          if (cache) {
            res.end(cache);
            return;
          }
          _render = function(err, txt) {
            if (err) {
              res.writeHead(500, {
                'Content-Type': mime_config[ctype] + charset
              });
              utils.logger.error(err);
              return res.end(err);
            } else {
              compiler.booster.set_compiled_cache(cachekey, txt);
              return res.end(txt);
            }
          };
          if (utils.path.exists(srcpath)) {
            config = new utils.config.parse(srcpath);
            return config.findExportFile(srcpath, function(path, parents) {
              if (options.noexport || is_deps) {
                path = srcpath;
              }
              if (path) {
                if (options.combine) {
                  return combine(path, parents, _render);
                } else {
                  return no_combine(path, parents, host, params, _render);
                }
              } else {
                return res.end("请确认文件 " + srcpath + " 存在于 fekit.config 的 export 中。");
              }
            });
          } else {
            return res.end("文件不存在 " + srcpath);
          }
        });
      };
    })(this));
    app = connect().use(connect.logger('tiny')).use(connect.query()).use(_rewriteObsoleteUrl(options)).use(rewrite(_routeRules(options))).use(connect.bodyParser()).use(fekitRouter).use(connect["static"](options.cwd, {
      hidden: true,
      redirect: true
    })).use(connect.directory(options.cwd));
    return listenPort(http.createServer(app), options.port || 80);
  };

  listenPort = function(server, port) {
    server.on("error", function(e) {
      if (e.code === 'EADDRINUSE') {
        console.log("[ERROR]: 端口 " + port + " 已经被占用, 请关闭占用该端口的程序或者使用其它端口.");
      }
      if (e.code === 'EACCES') {
        console.log("[ERROR]: 权限不足, 请使用sudo执行.");
      }
      return process.exit(1);
    });
    server.on("listening", function(e) {
      console.log("[LOG]: fekit server 运行成功, 端口为 " + port + ".");
      return console.log("[LOG]: 按 Ctrl + C 结束进程.");
    });
    return server.listen(port);
  };

  exports.run = function(options) {
    compiler.boost({
      cwd: process.cwd(),
      directories: [].concat(options.boost || [])
    });
    return setupServer(options);
  };

}).call(this);
